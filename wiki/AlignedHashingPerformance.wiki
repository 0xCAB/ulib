#Comparisons Among Several Hashing Implementations

= Introduction =

We will do some performance comparison. These including aligned hashing and several other popular implementations.  Of major concern is the duration for each find() and insert() operations.
In particular, we divide the experiments into two groups. In the first group, keys for insert() and find() are randomly generated. The second group, on the other hand, uses 0...NKEY sequential integers as keys. To focus on the performance of hash map, integer type is used for both key and value in the two groups. Also the hash function f: x->x is used by default.

= Experiment =

We ran the test program on a Linux 64-bit machine, with Intel Xeon E5620  @2.40GHz CPU and 64G memory. The test program was compiled using GCC 3.4.5 with different optimization levels. In the test program, initially four hash maps are created created, that is, STL hash_map, Google's sparse and dense hash_map, and ulib align_hash_map. The performance for random keys and sequential keys are tested separately. 

Apart from key generation, random or sequential, the tests involve two steps. In the first step, 10,000,000 keys were inserted into the four maps, since we know that all these hashing don't take into account the values, and values can be seen as they are actually 'attached' to their corresponding keys. For this reason, we are simply required to assign the values in a uniformed fashion. The following tables give comparison results in our test.

== With Random Key Generation ==
=== Compiled with Optimization Level 0 ===
|| *Name* || *Insert (sec)* || *Find (sec)* || 
|| *STL hash_map* || 0.736307 || 0.213671 ||
|| *Google sparse_hash_map* || 2.944162 || 0.730053 ||
|| *Google dense_hash_map* || 0.551075 || 0.210867 ||
|| *ulib align_hash_map* || *0.201506* || *0.071416* ||

=== Compiled with Optimization Level 2 ===
|| *Name* || *Insert (sec)* || *Find (sec)* || 
|| *STL hash_map* || 0.330408 || 0.085784 ||
|| *Google sparse_hash_map* || 0.505508 || 0.131285 ||
|| *Google dense_hash_map* || 0.107886 || 0.055064 ||
|| *ulib align_hash_map* || *0.101188* || *0.028575* ||

=== Compiled with Optimization Level 3 ===
|| *Name* || *Insert (sec)* || *Find (sec)* || 
|| *STL hash_map* || 0.345125 || 0.084649 ||
|| *Google sparse_hash_map* || 0.525760 || 0.131750 ||
|| *Google dense_hash_map* || 0.108172 || 0.054589 ||
|| *ulib align_hash_map* || *0.102181* || *0.029986* ||

== Conclusions ==
As we can see from the charts, compiler optimizations seem to have a great impact on the performance. Most significantly, the durations for google sparse hash map and dense hash map have decreased dramatically. According to the data, we see that ulib align hash map has the best scores for both insert() and find().