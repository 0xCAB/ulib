The following tests are based on 64-bit Linux with GCC 4.5.2, but they should give some indication for other operating systems and workloads. Three aspects of performance are covered in these tests. First, execution time per insertion, which is a key factor for write-intensive applications. Second, execution time per search, this is a fundamental performance indicator. Third, memory usage for storing the same data set.

For the results to be accurate, unsigned int is chosen as key and value types. Instead of using any particular hash function, the key is directly used as hash value. That is, h(x)=x is our hash function.

  * Execution time for insertion.
[http://ulib.googlecode.com/svn/wiki/ah_ins.png]

  * Execution time for search.
[http://ulib.googlecode.com/svn/wiki/ah_find.png]

  * Memory usage.
[http://ulib.googlecode.com/svn/wiki/ah_mem.png]

According to the experiments, aligned hashing has very outstanding performance as compared with other well-implemented libraries: it is the fastest in random search and insertion for both sequential and random keys.  In addition, sequential search speed is also excellent for aligned hash_map, though EASTL is the winner due to its hash code cache. Furthermore, ulib provides both C  and C++ implementations of aligned hashing while most other libraries support C++ only.

By using better compiler and compilation options, you can obtain a 10% to 30% speed increase in applications. It should also be noted that aligned hashing has several flags for further performance optimizations, such as AH_64BIT and AH_TIER_PROBING.

Before using aligned hashing, please read NotesOnAlignedHashing first. 