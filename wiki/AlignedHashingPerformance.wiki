#Comparisons Among Several Hashing Implementations

= Introduction =

In this page, we present some performance comparison between aligned hashing and several other popular implementations. In particular, we divide the experiments into two groups. In the first group, keys for insert() and find() are randomly generated. The second group, on the other hand, uses 0...NKEY sequential integers as keys. To focus on the performance of hash map, integer type is used for both key and value in the two groups. Also the hash function f: x->x is used by default.

= Experiment =

We ran the test program on a Linux 64-bit machine, with Intel Xeon E5620  @2.40GHz CPU and 64G memory. The test program was compiled using GCC 3.4.5 with different optimization levels. In the test program, initially four hash maps are created, namely STL hash_map, Google's sparse and dense hash_map, and ulib align_hash_map. The performance for random keys and sequential keys are tested separately. 

Apart from key generation, random or sequential, the tests consist of two steps. In the first step, 10,000,000 keys were inserted into the four maps, since we know that all these hashing don't take into account the values, and values can be seen as they are actually 'attached' to their corresponding keys. For this reason, we are simply required to assign the values in a uniformed fashion. The following tables give comparison results in our test.

== With Random Key Generation ==
  * Compiled with Optimization Level 0
|| *Name* || *Insert (sec)* || *Find (sec)* || 
|| *STL hash_map* || 0.736307 || 0.213671 ||
|| *Google sparse_hash_map* || 2.944162 || 0.730053 ||
|| *Google dense_hash_map* || 0.551075 || 0.210867 ||
|| *ulib align_hash_map* || *0.201506* || *0.071416* ||

  * Compiled with Optimization Level 2
|| *Name* || *Insert (sec)* || *Find (sec)* || 
|| *STL hash_map* || 0.330408 || 0.085784 ||
|| *Google sparse_hash_map* || 0.505508 || 0.131285 ||
|| *Google dense_hash_map* || 0.107886 || 0.055064 ||
|| *ulib align_hash_map* || *0.101188* || *0.028575* ||

  * Compiled with Optimization Level 3
|| *Name* || *Insert (sec)* || *Find (sec)* || 
|| *STL hash_map* || 0.345125 || 0.084649 ||
|| *Google sparse_hash_map* || 0.525760 || 0.131750 ||
|| *Google dense_hash_map* || 0.108172 || 0.054589 ||
|| *ulib align_hash_map* || *0.102181* || *0.029986* ||

== With Sequential Key Generation ==
  * Compiled with Optimization Level 0
|| *Name* || *Insert (sec)* || *Find (sec)* || 
|| *STL hash_map* || 0.460922 || 0.097423 ||
|| *Google sparse_hash_map* || 1.811730 || 0.586408 ||
|| *Google dense_hash_map* || 0.436950 || 0.119723 ||
|| *ulib align_hash_map* || *0.084637* || *0.033385* ||

  * Compiled with Optimization Level 2
|| *Name* || *Insert (sec)* || *Find (sec)* || 
|| *STL hash_map* || 0.094447 || 0.017092 ||
|| *Google sparse_hash_map* || 0.301150 || 0.062825 ||
|| *Google dense_hash_map* || 0.058016 || 0.012435 ||
|| *ulib align_hash_map* || *0.026941* || *0.006157* ||

  * Compiled with Optimization Level 3
|| *Name* || *Insert (sec)* || *Find (sec)* || 
|| *STL hash_map* || 0.094627 || 0.016336 ||
|| *Google sparse_hash_map* || 0.300022 || 0.063178 ||
|| *Google dense_hash_map* || 0.060236 || 0.012337 ||
|| *ulib align_hash_map* || *0.027598* || *0.006193* ||

== Conclusions ==
Generally, sequential keys yield faster insert() and find(). This is mainly due to that better locality is achieved, that is, with high probability sequential keys might be located in CPU cache. Also we can see from the tables, compiler optimizations seem to have a great impact on the performance. For this reason, durations for google sparse hash map and dense hash map have decreased dramatically. Overall, we see that ulib align_hash_map has the best scores for both insert() and find().

For people who are interested in the test program, please email me :-).