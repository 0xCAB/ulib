#labels Phase-Design
===Analysis of Chained Hashing===

Although it is generally believed that lock-free designs are more preferable to lock-based ones. We argue that the Chained hashing, which based on fine-grained locking, can outstrip many popular lock-free implementations theoretically and practically.

As a threshold matter, the lock-free version of an operation usually detours the operation, allowing for various exceptions. Thus it requires additional fix ups and could be error-prone.

In contrast, lock-based designs are generally more intuitive than those lock-free ones and sometimes could be superior, given scalable locks (http://pdos.csail.mit.edu/papers/linux:lock.pdf) and careful design.

The chained hashing adopts region locks to synchronize modification on each chain. Specifically, each lock is associated with one or more chains and acquiring the lock is need to access these associated chains.

The reasons in favor of the lock-based design over other lock-free ones involve simplicity of implementation, ease of analysis, and sound performance guarantees. Witness that acquiring or releasing a lock is quite efficient per se on modern architectures, provided no contentions. In addition, our lock-based design is provably scalable and efficient.

*Theorem 1: If a chained hash table with L locks are concurrently accessed by M threads, then the average execution time for processing N operations, insertion or search, is less than _NU(1/L + 1/M)_, where U is the average per operation time without locking.*

The above theorem asserts that only limited number of locks is sufficient to achieve good performance and scalability. The time overhead introduced by the locking, compared to the ideal model, is NU/L. Moreover, if C processors are available, then setting L=100C would sufficiently guarantee a less than 1% overhead.