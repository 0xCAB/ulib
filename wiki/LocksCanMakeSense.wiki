#labels Phase-Design
===Analysis of the Chaining Hash Table===

It is believed that lock-free designs are preferred over lock-based ones, however, the latter could still be desirable, given careful design. One telling example is the ulib's chaining hash table, which outstrips several popular lock-free implementations in both theory and practice.

The chaining hash table adopts regional locks to serialize concurrent modifications to each chain. Specifically, each lock is associated with one or more chains, of which the access requires acquisition of the lock. Thus, only the thread holding the lock can alter the chains at any instant.

This implementation is intuitive, concise, and most importantly scalable. To understand why it is scalable, we should first figure out how many locks are sufficient. We have the following theorem:

*Theorem 1: Given a chaining hash table with L locks are concurrently accessed by M threads, then the expected completion time for processing N operations, such as insertion and search, is between _NT(1/L + 1/M - 1/(LM))_ and _NT(1/L + 1/M)_, where T is the average per operation time without locking.*

This theorem suggests that the overhead posed by regional locks amounts to _T/L_, in the worst case, for any operation that has a completion time of T without the presence of regional locks. In other words, _1/L_ percent extra work is required for any operation as a result of the locking strategy in chaining hash table, giving a speedup of at least _(LM)/(L + M)_ in the worst case.

On the other hand, lock-free implementations are generally more sophisticate and much less intuitive than lock-based ones. The lock-free version of an operation usually detours the operation and incurs various exceptions to handle. Even if lock-free is ultimately achieved, the additional work introduced to get it working might be expensive.

Another drawback of lock-free implementations is that they often use specific atomic operations, which are hardware dependent. For example, compare-and-swap (CAS) and fetch-and-store (FAS) are two frequently used atomic routines in lock-free algorithms. One risk of using these routines involves that torrential performance of CAS or FAS among threads overwhelms the system bus, which dramatically undermines the overall performance of the application.